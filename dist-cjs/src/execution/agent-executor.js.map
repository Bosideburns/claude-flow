{"version":3,"sources":["../../../src/execution/agent-executor.ts"],"sourcesContent":["/**\n * Agent Executor - Wrapper around agentic-flow execution engine\n * Integrates agentic-flow agents with claude-flow hooks and coordination\n */\n\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport path from 'path';\nimport fs from 'fs-extra';\n\nconst execAsync = promisify(exec);\n\nexport interface AgentExecutionOptions {\n  agent: string;\n  task: string;\n  provider?: 'anthropic' | 'openrouter' | 'onnx' | 'gemini';\n  model?: string;\n  temperature?: number;\n  maxTokens?: number;\n  outputFormat?: 'text' | 'json' | 'markdown';\n  stream?: boolean;\n  verbose?: boolean;\n  retryOnError?: boolean;\n  timeout?: number;\n}\n\nexport interface AgentExecutionResult {\n  success: boolean;\n  output: string;\n  error?: string;\n  provider: string;\n  model: string;\n  tokens?: number;\n  cost?: number;\n  duration: number;\n  agent: string;\n  task: string;\n}\n\nexport class AgentExecutor {\n  private readonly agenticFlowPath: string;\n  private readonly hooksManager: any;\n\n  constructor(hooksManager?: any) {\n    this.hooksManager = hooksManager;\n    // Agentic-flow is installed as npm dependency\n    this.agenticFlowPath = 'npx agentic-flow';\n  }\n\n  /**\n   * Execute an agent with agentic-flow\n   */\n  async execute(options: AgentExecutionOptions): Promise<AgentExecutionResult> {\n    const startTime = Date.now();\n\n    try {\n      // Trigger pre-execution hook\n      if (this.hooksManager) {\n        await this.hooksManager.trigger('pre-agent-execute', {\n          agent: options.agent,\n          task: options.task,\n          provider: options.provider || 'anthropic',\n          timestamp: Date.now()\n        });\n      }\n\n      // Build agentic-flow command\n      const command = this.buildCommand(options);\n\n      // Execute command\n      const { stdout, stderr } = await execAsync(command, {\n        timeout: options.timeout || 300000, // 5 minutes default\n        maxBuffer: 10 * 1024 * 1024, // 10MB buffer\n      });\n\n      const duration = Date.now() - startTime;\n\n      // Parse output\n      const result: AgentExecutionResult = {\n        success: true,\n        output: stdout,\n        provider: options.provider || 'anthropic',\n        model: options.model || 'default',\n        duration,\n        agent: options.agent,\n        task: options.task,\n      };\n\n      // Trigger post-execution hook\n      if (this.hooksManager) {\n        await this.hooksManager.trigger('post-agent-execute', {\n          agent: options.agent,\n          task: options.task,\n          result,\n          success: true,\n        });\n      }\n\n      return result;\n    } catch (error: any) {\n      const duration = Date.now() - startTime;\n\n      const result: AgentExecutionResult = {\n        success: false,\n        output: '',\n        error: error.message,\n        provider: options.provider || 'anthropic',\n        model: options.model || 'default',\n        duration,\n        agent: options.agent,\n        task: options.task,\n      };\n\n      // Trigger error hook\n      if (this.hooksManager) {\n        await this.hooksManager.trigger('agent-execute-error', {\n          agent: options.agent,\n          task: options.task,\n          error: error.message,\n        });\n      }\n\n      return result;\n    }\n  }\n\n  /**\n   * List available agents from agentic-flow\n   */\n  async listAgents(source?: 'all' | 'package' | 'local'): Promise<string[]> {\n    try {\n      // Agentic-flow uses 'agent list' command\n      const command = source\n        ? `${this.agenticFlowPath} agent list --filter ${source}`\n        : `${this.agenticFlowPath} agent list`;\n\n      const { stdout } = await execAsync(command);\n\n      // Parse agent list from output\n      const agents = stdout\n        .split('\\n')\n        .filter(line => line.trim())\n        .map(line => line.trim());\n\n      return agents;\n    } catch (error: any) {\n      console.error('Failed to list agents:', error.message);\n      return [];\n    }\n  }\n\n  /**\n   * Get agent information\n   */\n  async getAgentInfo(agentName: string): Promise<any> {\n    try {\n      // Agentic-flow uses 'agent info' command\n      const command = `${this.agenticFlowPath} agent info ${agentName}`;\n      const { stdout } = await execAsync(command);\n\n      // Try to parse as JSON if it looks like JSON\n      if (stdout.trim().startsWith('{')) {\n        return JSON.parse(stdout);\n      }\n\n      // Otherwise return as plain text\n      return { name: agentName, description: stdout };\n    } catch (error: any) {\n      console.error('Failed to get agent info:', error.message);\n      return null;\n    }\n  }\n\n  /**\n   * Build agentic-flow command from options\n   */\n  private buildCommand(options: AgentExecutionOptions): string {\n    const parts = [this.agenticFlowPath];\n\n    // Agentic-flow uses --agent flag directly (no 'execute' subcommand)\n    parts.push('--agent', options.agent);\n    parts.push('--task', `\"${options.task.replace(/\"/g, '\\\\\"')}\"`);\n\n    if (options.provider) {\n      parts.push('--provider', options.provider);\n    }\n\n    if (options.model) {\n      parts.push('--model', options.model);\n    }\n\n    if (options.temperature !== undefined) {\n      parts.push('--temperature', options.temperature.toString());\n    }\n\n    if (options.maxTokens) {\n      parts.push('--max-tokens', options.maxTokens.toString());\n    }\n\n    if (options.outputFormat) {\n      parts.push('--output-format', options.outputFormat);\n    }\n\n    if (options.stream) {\n      parts.push('--stream');\n    }\n\n    if (options.verbose) {\n      parts.push('--verbose');\n    }\n\n    // Note: agentic-flow doesn't have a --retry flag\n    // Retry logic should be handled by AgentExecutor if needed\n\n    return parts.join(' ');\n  }\n}\n\nexport default AgentExecutor;\n"],"names":["exec","promisify","execAsync","AgentExecutor","agenticFlowPath","hooksManager","execute","options","startTime","Date","now","trigger","agent","task","provider","timestamp","command","buildCommand","stdout","stderr","timeout","maxBuffer","duration","result","success","output","model","error","message","listAgents","source","agents","split","filter","line","trim","map","console","getAgentInfo","agentName","startsWith","JSON","parse","name","description","parts","push","replace","temperature","undefined","toString","maxTokens","outputFormat","stream","verbose","join"],"mappings":"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"}