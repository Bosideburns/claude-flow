{"version":3,"sources":["../../../src/reasoningbank/reasoningbank-adapter.js"],"sourcesContent":["/**\n * ReasoningBank Adapter for Claude-Flow\n *\n * Wraps agentic-flow's ReasoningBank SDK for use in claude-flow memory commands\n * Performance-optimized with caching, timeouts, and async embeddings\n */\n\nimport {  db, initialize, retrieveMemories, computeEmbedding, loadConfig } from 'agentic-flow/dist/reasoningbank/index.js';\nimport { v4 as uuidv4 } from 'uuid';\n\n// Query result cache (LRU)\nconst queryCache = new Map();\nconst CACHE_SIZE = 100;\nconst CACHE_TTL = 60000; // 60 seconds\n\n// Async embedding processing queue\nconst embeddingQueue = [];\nlet processingQueue = false;\n\n/**\n * Initialize ReasoningBank database with performance optimizations\n */\nexport async function initializeReasoningBank() {\n  // Set database path\n  process.env.CLAUDE_FLOW_DB_PATH = '.swarm/memory.db';\n\n  await initialize();\n  await optimizeDatabase();\n  return true;\n}\n\n/**\n * Add database indexes for query performance\n */\nasync function optimizeDatabase() {\n  try {\n    const dbInstance = db.getDb();\n\n    // Add indexes for common queries\n    dbInstance.exec(`\n      -- Index on confidence for sorting\n      CREATE INDEX IF NOT EXISTS idx_patterns_confidence\n      ON patterns(confidence DESC);\n\n      -- Index on usage_count for sorting\n      CREATE INDEX IF NOT EXISTS idx_patterns_usage\n      ON patterns(usage_count DESC);\n\n      -- Index on created_at for time-based queries\n      CREATE INDEX IF NOT EXISTS idx_patterns_created\n      ON patterns(created_at DESC);\n\n      -- Index on memory_id for embeddings lookup\n      CREATE INDEX IF NOT EXISTS idx_embeddings_memory\n      ON pattern_embeddings(memory_id);\n    `);\n  } catch (error) {\n    console.warn('[ReasoningBank] Failed to create indexes:', error.message);\n  }\n}\n\n/**\n * Store a memory in ReasoningBank (optimized with async embeddings)\n */\nexport async function storeMemory(key, value, options = {}) {\n  const memoryId = `mem_${uuidv4()}`;\n\n  const memory = {\n    id: memoryId,\n    type: options.type || 'fact',\n    pattern_data: JSON.stringify({\n      key,\n      value,\n      namespace: options.namespace || 'default',\n      agent: options.agent || 'memory-agent',\n      domain: options.domain || 'general',\n    }),\n    confidence: options.confidence || 0.8,\n    usage_count: 0,\n    created_at: new Date().toISOString(),\n  };\n\n  // Store memory immediately (fast, no blocking)\n  db.upsertMemory(memory);\n\n  // Invalidate query cache when new memory is added\n  queryCache.clear();\n\n  // Queue embedding computation for background processing (unless disabled)\n  if (options.async !== false) {\n    embeddingQueue.push({ memoryId, key, value });\n    processEmbeddingQueue(); // Non-blocking\n  } else {\n    // Synchronous mode for critical operations\n    await computeAndStoreEmbedding(memoryId, key, value);\n  }\n\n  return memoryId;\n}\n\n/**\n * Process embedding queue in background\n */\nasync function processEmbeddingQueue() {\n  if (processingQueue || embeddingQueue.length === 0) return;\n\n  processingQueue = true;\n\n  while (embeddingQueue.length > 0) {\n    const batch = embeddingQueue.splice(0, 5); // Process 5 at a time\n\n    await Promise.allSettled(\n      batch.map(({ memoryId, key, value }) =>\n        computeAndStoreEmbedding(memoryId, key, value)\n      )\n    );\n  }\n\n  processingQueue = false;\n}\n\n/**\n * Compute and store embedding for a memory\n */\nasync function computeAndStoreEmbedding(memoryId, key, value) {\n  try {\n    const config = loadConfig();\n    const embeddingModel = config.embeddings.provider || 'claude';\n\n    const embedding = await computeEmbedding(`${key}: ${value}`);\n    const vectorArray = new Float32Array(embedding);\n\n    db.upsertEmbedding({\n      memory_id: memoryId,\n      vector: vectorArray,\n      model: embeddingModel,\n      dims: vectorArray.length,\n      created_at: new Date().toISOString(),\n    });\n  } catch (error) {\n    console.warn(`[ReasoningBank] Failed to compute embedding for ${memoryId}:`, error.message);\n  }\n}\n\n/**\n * Query memories from ReasoningBank (optimized with caching and timeout)\n */\nexport async function queryMemories(searchQuery, options = {}) {\n  // Check cache first\n  const cached = getCachedQuery(searchQuery, options);\n  if (cached) {\n    return cached;\n  }\n\n  const timeout = options.timeout || 3000; // 3s default timeout\n\n  try {\n    // Race between semantic search and timeout\n    const memories = await Promise.race([\n      retrieveMemories(searchQuery, {\n        domain: options.domain || 'general',\n        agent: options.agent || 'memory-agent',\n        k: options.limit || 10,\n      }),\n      new Promise((_, reject) =>\n        setTimeout(() => reject(new Error('Query timeout')), timeout)\n      )\n    ]);\n\n    const results = memories.map(mem => {\n      try {\n        const data = JSON.parse(mem.pattern_data);\n        return {\n          id: mem.id,\n          key: data.key,\n          value: data.value,\n          namespace: data.namespace,\n          confidence: mem.confidence,\n          usage_count: mem.usage_count,\n          created_at: mem.created_at,\n          score: mem.score || 0,\n        };\n      } catch {\n        return null;\n      }\n    }).filter(Boolean);\n\n    // If semantic search returns no results, try SQL fallback\n    // (handles case where embeddings don't exist yet)\n    if (results.length === 0) {\n      console.warn('[ReasoningBank] Semantic search returned 0 results, trying SQL fallback');\n      const fallbackResults = await queryMemoriesFast(searchQuery, options);\n      setCachedQuery(searchQuery, options, fallbackResults);\n      return fallbackResults;\n    }\n\n    // Cache successful results\n    setCachedQuery(searchQuery, options, results);\n    return results;\n  } catch (error) {\n    // Fast SQL fallback on timeout or error\n    console.warn('[ReasoningBank] Using fast SQL fallback:', error.message);\n    const results = await queryMemoriesFast(searchQuery, options);\n\n    // Cache fallback results too\n    setCachedQuery(searchQuery, options, results);\n    return results;\n  }\n}\n\n/**\n * Fast SQL-based query fallback (optimized)\n */\nasync function queryMemoriesFast(searchQuery, options = {}) {\n  const dbInstance = db.getDb();\n  const limit = options.limit || 10;\n  const namespace = options.namespace;\n\n  // Use optimized query with indexes\n  let query = `\n    SELECT\n      id,\n      pattern_data,\n      confidence,\n      usage_count,\n      created_at\n    FROM patterns\n    WHERE 1=1\n  `;\n\n  const params = [];\n\n  // Add namespace filter if provided\n  if (namespace) {\n    query += ` AND pattern_data LIKE ?`;\n    params.push(`%\"namespace\":\"${namespace}\"%`);\n  }\n\n  // Add search filter - check both key and value\n  query += ` AND (\n    pattern_data LIKE ? OR\n    pattern_data LIKE ?\n  )`;\n  params.push(`%\"key\":\"%${searchQuery}%\"%`, `%\"value\":\"%${searchQuery}%\"%`);\n\n  // Use indexed sort\n  query += ` ORDER BY confidence DESC, usage_count DESC LIMIT ?`;\n  params.push(limit);\n\n  const rows = dbInstance.prepare(query).all(...params);\n\n  return rows.map(row => {\n    try {\n      const data = JSON.parse(row.pattern_data);\n      return {\n        id: row.id,\n        key: data.key,\n        value: data.value,\n        namespace: data.namespace,\n        confidence: row.confidence,\n        usage_count: row.usage_count,\n        created_at: row.created_at,\n      };\n    } catch {\n      return null;\n    }\n  }).filter(Boolean);\n}\n\n/**\n * Get cached query results\n */\nfunction getCachedQuery(searchQuery, options) {\n  const cacheKey = JSON.stringify({ searchQuery, options });\n  const cached = queryCache.get(cacheKey);\n\n  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {\n    return cached.results;\n  }\n\n  return null;\n}\n\n/**\n * Set cached query results (LRU eviction)\n */\nfunction setCachedQuery(searchQuery, options, results) {\n  const cacheKey = JSON.stringify({ searchQuery, options });\n\n  // LRU eviction\n  if (queryCache.size >= CACHE_SIZE) {\n    const firstKey = queryCache.keys().next().value;\n    queryCache.delete(firstKey);\n  }\n\n  queryCache.set(cacheKey, {\n    results,\n    timestamp: Date.now()\n  });\n}\n\n/**\n * List all memories\n */\nexport async function listMemories(options = {}) {\n  const dbInstance = db.getDb();\n\n  const limit = options.limit || 10;\n  const sortBy = options.sort || 'created_at';\n  const sortOrder = options.order || 'DESC';\n\n  const rows = dbInstance.prepare(`\n    SELECT * FROM patterns\n    ORDER BY ${sortBy} ${sortOrder}\n    LIMIT ?\n  `).all(limit);\n\n  return rows.map(row => {\n    try {\n      const data = JSON.parse(row.pattern_data);\n      return {\n        id: row.id,\n        key: data.key,\n        value: data.value,\n        namespace: data.namespace,\n        confidence: row.confidence,\n        usage_count: row.usage_count,\n        created_at: row.created_at,\n      };\n    } catch {\n      return null;\n    }\n  }).filter(Boolean);\n}\n\n/**\n * Get ReasoningBank statistics\n */\nexport async function getStatus() {\n  const dbInstance = db.getDb();\n\n  const stats = dbInstance.prepare(`\n    SELECT\n      COUNT(*) as total_memories,\n      AVG(confidence) as avg_confidence,\n      SUM(usage_count) as total_usage\n    FROM patterns\n  `).get();\n\n  const embeddingCount = dbInstance.prepare(`\n    SELECT COUNT(*) as count FROM pattern_embeddings\n  `).get();\n\n  const trajectoryCount = dbInstance.prepare(`\n    SELECT COUNT(*) as count FROM task_trajectories\n  `).get();\n\n  return {\n    total_memories: stats.total_memories || 0,\n    avg_confidence: stats.avg_confidence || 0,\n    total_usage: stats.total_usage || 0,\n    total_embeddings: embeddingCount.count || 0,\n    total_trajectories: trajectoryCount.count || 0,\n  };\n}\n\n/**\n * Check which ReasoningBank tables are present in the database\n * Returns object with table names and their existence status\n */\nexport async function checkReasoningBankTables() {\n  try {\n    const dbInstance = db.getDb();\n\n    // Required ReasoningBank tables\n    const requiredTables = [\n      'patterns',\n      'pattern_embeddings',\n      'pattern_links',\n      'task_trajectories',\n      'matts_runs',\n      'consolidation_runs',\n      'metrics_log'\n    ];\n\n    // Query existing tables\n    const existingTables = dbInstance.prepare(`\n      SELECT name FROM sqlite_master\n      WHERE type='table'\n    `).all().map(row => row.name);\n\n    // Check which required tables are missing\n    const missingTables = requiredTables.filter(table => !existingTables.includes(table));\n\n    return {\n      exists: missingTables.length === 0,\n      existingTables,\n      missingTables,\n      requiredTables\n    };\n  } catch (error) {\n    return {\n      exists: false,\n      existingTables: [],\n      missingTables: [],\n      requiredTables: [],\n      error: error.message\n    };\n  }\n}\n\n/**\n * Migrate existing database to add missing ReasoningBank tables\n */\nexport async function migrateReasoningBank() {\n  try {\n    // Check current state\n    const tableCheck = await checkReasoningBankTables();\n\n    if (tableCheck.exists) {\n      return {\n        success: true,\n        message: 'All ReasoningBank tables already exist',\n        migrated: false\n      };\n    }\n\n    // Run full initialization which will create missing tables\n    await initializeReasoningBank();\n\n    // Verify migration\n    const afterCheck = await checkReasoningBankTables();\n\n    return {\n      success: afterCheck.exists,\n      message: `Migration completed: ${tableCheck.missingTables.length} tables added`,\n      migrated: true,\n      addedTables: tableCheck.missingTables\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: `Migration failed: ${error.message}`,\n      error: error.message\n    };\n  }\n}\n"],"names":["db","initialize","retrieveMemories","computeEmbedding","loadConfig","v4","uuidv4","queryCache","Map","CACHE_SIZE","CACHE_TTL","embeddingQueue","processingQueue","initializeReasoningBank","process","env","CLAUDE_FLOW_DB_PATH","optimizeDatabase","dbInstance","getDb","exec","error","console","warn","message","storeMemory","key","value","options","memoryId","memory","id","type","pattern_data","JSON","stringify","namespace","agent","domain","confidence","usage_count","created_at","Date","toISOString","upsertMemory","clear","async","push","processEmbeddingQueue","computeAndStoreEmbedding","length","batch","splice","Promise","allSettled","map","config","embeddingModel","embeddings","provider","embedding","vectorArray","Float32Array","upsertEmbedding","memory_id","vector","model","dims","queryMemories","searchQuery","cached","getCachedQuery","timeout","memories","race","k","limit","_","reject","setTimeout","Error","results","mem","data","parse","score","filter","Boolean","fallbackResults","queryMemoriesFast","setCachedQuery","query","params","rows","prepare","all","row","cacheKey","get","now","timestamp","size","firstKey","keys","next","delete","set","listMemories","sortBy","sort","sortOrder","order","getStatus","stats","embeddingCount","trajectoryCount","total_memories","avg_confidence","total_usage","total_embeddings","count","total_trajectories","checkReasoningBankTables","requiredTables","existingTables","name","missingTables","table","includes","exists","migrateReasoningBank","tableCheck","success","migrated","afterCheck","addedTables"],"mappings":"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"}